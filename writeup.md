# **Finding Lane Lines on the Road** 


### 1. Describe your pipeline. 

*  Get images from folder and convert images to gray scale.

*  Image has to be in gray scale due to color image have 3 color channels which would complex to handle.Once image
   is converted to gray scale run ```image.shape``` which would should not show third parameter as it is single channel image.
   
* Since canny edge detection is susceptible to noise in the image it has to be first Blurred before using it.Used 5x5 Kernal size matrix to apply on image for blur. Gaussian blurring is highly effective in removing noise from the image.
    More details can be found [here](https://docs.opencv.org/3.1.0/d4/d13/tutorial_py_filtering.html)
    
* Canny edge detection is used and minimum threshold = 50 and maxinum threshold = 150 is passed. it is recommended to have 2 or 3 high to low threshold ratio.
    More details for canny edge detection can be found [here](https://docs.opencv.org/3.1.0/da/d22/tutorial_py_canny.html)
    
* Since we wanted to target on lane part of a image, we need to create boundary in a image so that further algorithm can be applied.Created vertices of array where boundary within a image is created and mask and ployfill is used to fill pixels at the area covered by vertices

* Hough Line transform is used to convert lanes in the image with lines and more details can be found can be found 
  [here](https://docs.opencv.org/2.4/doc/tutorials/imgproc/imgtrans/hough_lines/hough_lines.html)
  
* For drawing on lane lines generated by Hough transform, each line will have data 
like
```
[[1,0,][110 159 202]
[110 159 202]
[110 159 202]
.......
```

Loop  through each entry and get (x1,y1) and (x2,y2)  coordinates.

```
Slope m in y=mx+c for (x1,y1) and (x2,y2) points in image space

slope = (y2-y1)/(x2-x1) 
```

Difference of X coordinates can lead to infinite slope so needs to be handled.

```
∀ x ∈ N, -∞ <x < +∞
∀ x ∈ Z, -∞ < x < +∞
```
Meaning every natural number (positive integers, i.e., 0, 1, 2, …) is smaller than 
positive infinity (+∞) and all positive and negative integers (…, -2, -1, 0, 1, 2, …) 
are bigger than negative infinity (-∞) and smaller than positive infinity.  

```if slope < 0.0 and slope > -math.inf ```

Get left slopes,intercept and (x,y) coordinates

```if slope < 0.0 and slope > -math.inf ```

Get right slopes,intercept and (x,y) coordinates

Use ```np.mean``` to calculate mean slope and intercept

Use ```x = ( y - c ) / m ``` to get new xmin and xmax values where ymin is minimum y coordinate in the hough transformed image
and ymax is height of image ```image.shape[0]```

Use ***addWeighted*** method in OpenCV to blend red color lines in the image.More details can be found [here](https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_core/py_image_arithmetics/py_image_arithmetics.html)



### 2. Identify potential shortcomings with your current pipeline

Current pipeline can not handle images and video which have curves.This can be fixed using Hough transformation for curves and more details can be found [here](https://docs.opencv.org/master/d9/db0/tutorial_hough_lines.html)


### 3. Suggest possible improvements to your pipeline

I have added plt.subplot so that once we run all images we can see original and modified images in parallel.
